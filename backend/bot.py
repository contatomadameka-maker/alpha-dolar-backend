"""
ALPHA DOLAR 2.0 - Bot de Trading Automatizado
Motor Principal do Bot
ATUALIZADO: IntegraÃ§Ã£o com 15 estratÃ©gias novas
"""
import time
import sys
from datetime import datetime

try:
    from .config import BotConfig, validate_config
    from .deriv_api import DerivAPI
    from .risk_management.martingale import Martingale
    from .risk_management.stop_loss import StopLoss
except ImportError:
    from config import BotConfig, validate_config
    from deriv_api import DerivAPI
    from risk_management.martingale import Martingale
    from risk_management.stop_loss import StopLoss


class AlphaDolar:
    """Motor principal do bot Alpha Dolar 2.0"""

    def __init__(self, strategy=None, use_martingale=True, bot_number=None):
        self.bot_name = "ALPHA DOLAR 2.0"
        self.version = "2.0.0"

        self.api = DerivAPI()

        if strategy is None:
            raise ValueError("EstratÃ©gia nÃ£o pode ser None!")
        self.strategy = strategy

        self.martingale = Martingale() if use_martingale else None
        self.stop_loss = StopLoss()

        self.is_running = False
        self.current_stake = BotConfig.STAKE_INICIAL
        self.waiting_contract = False
        self.current_contract_id = None

        # âœ… Martingale inteligente: rastreia perda acumulada para cÃ¡lculo exato
        self.perda_acumulada = 0.0
        self.PAYOUT_RATE = 0.88  # retorno mÃ©dio Deriv (88%)

        self.tick_history = []
        self.max_tick_history = 200

        self.trades_hoje = 0
        self.inicio_sessao = datetime.now()

    def print_header(self):
        print("\n" + "="*70)
        print(f"ðŸ¤– {self.bot_name} v{self.version}")
        print("="*70)
        strategy_name = getattr(self.strategy, 'name', 'EstratÃ©gia Personalizada')
        print(f"ðŸ“Š EstratÃ©gia: {strategy_name}")
        if hasattr(self.strategy, 'get_info'):
            info = self.strategy.get_info()
            print(f"   Tipo: {info.get('tier', 'N/A')}")
            print(f"   Contratos: {info.get('contract_type', 'N/A')}")
            print(f"   Indicadores: {info.get('indicators', 'N/A')}")
        print(f"ðŸ’° Stake Inicial: ${BotConfig.STAKE_INICIAL}")
        print(f"ðŸŽ¯ Lucro Alvo: ${BotConfig.LUCRO_ALVO}")
        print(f"ðŸ›‘ Limite Perda: ${BotConfig.LIMITE_PERDA}")
        print(f"âš¡ Martingale: {'Ativado' if self.martingale else 'Desativado'}")
        print("="*70 + "\n")

    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime('%H:%M:%S')
        emoji = {
            "INFO": "â„¹ï¸", "SUCCESS": "âœ…", "ERROR": "âŒ",
            "WARNING": "âš ï¸", "TRADE": "ðŸ’°", "WIN": "ðŸŽ‰", "LOSS": "ðŸ˜ž"
        }.get(level, "ðŸ“")
        print(f"[{timestamp}] {emoji} {message}")

    def on_tick(self, tick_data):
        if self.waiting_contract:
            return

        if 'quote' in tick_data:
            price = float(tick_data['quote'])
            self.tick_history.append(price)
            if len(self.tick_history) > self.max_tick_history:
                self.tick_history.pop(0)

        pode_operar, motivo = self.stop_loss.pode_operar(self.api.balance)
        if not pode_operar:
            self.log(motivo, "WARNING")
            self.stop()
            return

        if self.trades_hoje >= BotConfig.MAX_TRADES_PER_DAY:
            self.log(f"Limite diÃ¡rio de {BotConfig.MAX_TRADES_PER_DAY} trades atingido!", "WARNING")
            self.stop()
            return

        signal_data = self.analyze_strategy(tick_data)

        if signal_data and signal_data.get('signal'):
            direction = signal_data['signal']
            confidence = signal_data.get('confidence', 0)
            self.log(f"ðŸ“Š Sinal detectado: {direction} | ConfianÃ§a: {confidence:.1f}%", "TRADE")
            self.executar_trade(direction, signal_data)

    def analyze_strategy(self, tick_data):
        if hasattr(self.strategy, 'analyze'):
            if len(self.tick_history) < 30:
                return None
            return self.strategy.analyze(self.tick_history)
        elif hasattr(self.strategy, 'should_enter'):
            should_enter, direction, confidence = self.strategy.should_enter(tick_data)
            if should_enter and direction:
                return {
                    'signal': direction,
                    'confidence': confidence * 100,
                    'contract_type': direction,
                    'parameters': None
                }
        return None

    def _calcular_stake_recuperacao(self):
        """
        Calcula stake para recuperar perda acumulada + lucro mÃ­nimo.
        FÃ³rmula: stake = (perda_acumulada + lucro_alvo) / payout_rate
        Onde payout_rate = 0.88 (88% de retorno na Deriv)
        """
        if self.perda_acumulada <= 0:
            return BotConfig.STAKE_INICIAL
        
        stake_ideal = (self.perda_acumulada + BotConfig.STAKE_INICIAL) / self.PAYOUT_RATE
        # Arredonda para 2 casas e garante mÃ­nimo
        stake = max(BotConfig.STAKE_INICIAL, round(stake_ideal, 2))
        
        # SeguranÃ§a: nÃ£o arrisca mais que 30% do saldo
        max_stake = self.api.balance * 0.30
        return min(stake, max_stake)

    def executar_trade(self, direction, signal_data=None):
        # âœ… Martingale inteligente: calcula stake para recuperar perda acumulada
        if self.martingale and self.perda_acumulada > 0:
            stake = self._calcular_stake_recuperacao()
        elif hasattr(self.strategy, 'get_stake'):
            stake = self.strategy.get_stake()
        elif self.martingale:
            stake = self.martingale.stake_atual
        else:
            stake = self.current_stake

        if self.api.balance < stake:
            self.log(f"Saldo insuficiente! NecessÃ¡rio: ${stake:.2f} | DisponÃ­vel: ${self.api.balance:.2f}", "ERROR")
            return

        if signal_data and signal_data.get('parameters'):
            params = signal_data['parameters'].copy()
            params['amount'] = stake
            contract_type = signal_data.get('contract_type', direction)
            barrier = params.get('barrier')
        else:
            params = self.strategy.get_contract_params(direction)
            contract_type = params.get("contract_type", direction)
            barrier = None

        log_msg = f"ðŸŽ¯ Executando {contract_type} | Stake: ${stake:.2f}"
        if barrier is not None:
            log_msg += f" | Barreira: {barrier}"
        self.log(log_msg, "TRADE")

        proposal_params = {
            'contract_type': contract_type,
            'symbol': params.get("symbol", BotConfig.DEFAULT_SYMBOL),
            'amount': stake,
            'duration': params.get("duration", 1),
            'duration_unit': params.get("duration_unit", "t")
        }
        if barrier is not None:
            proposal_params['barrier'] = barrier

        self.api.get_proposal(**proposal_params)
        self.waiting_contract = True
        self.trades_hoje += 1

        if self.martingale:
            self.martingale.registrar_trade(stake)

    def on_contract_update(self, contract_data):
        status = contract_data.get("status")
        if status not in ["won", "lost"]:
            return

        profit = float(contract_data.get("profit", 0))
        contract_id = contract_data.get("contract_id")
        vitoria = status == "won"

        if vitoria:
            self.log(f"ðŸŽ‰ VITÃ“RIA! Lucro: ${profit:.2f} | ID: {contract_id}", "WIN")
            self.perda_acumulada = 0.0  # âœ… reseta apÃ³s vitÃ³ria
        else:
            self.log(f"ðŸ˜ž DERROTA! Perda: ${profit:.2f} | ID: {contract_id}", "LOSS")
            self.perda_acumulada += abs(profit)  # âœ… acumula perda

        # âœ… Atualiza martingale da estratÃ©gia
        if hasattr(self.strategy, 'on_trade_result'):
            self.strategy.on_trade_result(vitoria)

        if self.martingale:
            self.martingale.calcular_proximo_stake(vitoria)
            info = self.martingale.get_info()
            proximo = self._calcular_stake_recuperacao() if self.perda_acumulada > 0 else info['stake_atual']
            self.log(f"ðŸ“Š PrÃ³ximo stake: ${proximo:.2f} | Perda acum: ${self.perda_acumulada:.2f} | Step: {info['step_atual']}/{info['max_steps']}", "INFO")

        self.stop_loss.registrar_trade(profit, vitoria)
        stats = self.stop_loss.get_estatisticas()
        self.log(f"ðŸ“ˆ LÃ­quido: ${stats['saldo_liquido']:+.2f} | Win Rate: {stats['win_rate']:.1f}% | Trades: {stats['total_trades']}", "INFO")

        self.waiting_contract = False
        self.current_contract_id = None

        deve_parar, motivo = self.stop_loss.deve_parar()
        if deve_parar:
            self.log(motivo, "WARNING")
            self.stop()

    def on_balance_update(self, balance):
        self.log(f"ðŸ’° Saldo atualizado: ${balance:.2f}", "INFO")

    def start(self):
        try:
            # âœ… validate_config() sÃ³ valida parÃ¢metros bÃ¡sicos â€” nÃ£o bloqueia por stake
            if not validate_config():
                return False

            self.print_header()

            self.log("Conectando Ã  Deriv API...", "INFO")
            if not self.api.connect():
                self.log("Falha na conexÃ£o!", "ERROR")
                return False

            self.log("Autorizando...", "INFO")
            if not self.api.authorize():
                self.log("Falha na autorizaÃ§Ã£o!", "ERROR")
                return False

            self.log(f"âœ… Autorizado! Saldo: ${self.api.balance:.2f} {self.api.currency}", "SUCCESS")

            # âœ… Verifica saldo mÃ­nimo sÃ³ para garantir que conta tem algum saldo
            if self.api.balance <= 0:
                self.log("Saldo zerado! ImpossÃ­vel operar.", "ERROR")
                return False

            self.api.set_tick_callback(self.on_tick)
            self.api.set_contract_callback(self.on_contract_update)
            self.api.set_balance_callback(self.on_balance_update)

            self.api.subscribe_ticks(BotConfig.DEFAULT_SYMBOL)

            self.is_running = True
            self.log("ðŸš€ Bot iniciado! Aguardando sinais...", "SUCCESS")

            while self.is_running:
                time.sleep(1)

            return True

        except KeyboardInterrupt:
            self.log("\nâ¹ï¸ Bot interrompido pelo usuÃ¡rio", "WARNING")
            self.stop()
            return True
        except Exception as e:
            self.log(f"Erro fatal: {e}", "ERROR")
            import traceback
            traceback.print_exc()
            return False

    def stop(self):
        self.is_running = False
        self.exibir_relatorio_final()
        if self.api:
            self.api.disconnect()
        self.log("Bot encerrado", "INFO")

    def exibir_relatorio_final(self):
        print("\n" + "="*70)
        print("ðŸ“Š RELATÃ“RIO FINAL DA SESSÃƒO")
        print("="*70)
        stats = self.stop_loss.get_estatisticas()
        print(f"\nðŸ’° Resultados Financeiros:")
        print(f"   Saldo LÃ­quido: ${stats['saldo_liquido']:+.2f}")
        print(f"   Lucro Total: ${stats['lucro_total']:.2f}")
        print(f"   Perda Total: ${stats['perda_total']:.2f}")
        print(f"\nðŸ“ˆ EstatÃ­sticas:")
        print(f"   Total de Trades: {stats['total_trades']}")
        print(f"   VitÃ³rias: {stats['vitorias']}")
        print(f"   Derrotas: {stats['derrotas']}")
        print(f"   Win Rate: {stats['win_rate']:.2f}%")
        print(f"\nâ±ï¸ Tempo de SessÃ£o: {stats['tempo_sessao']}")
        print("\n" + "="*70 + "\n")
